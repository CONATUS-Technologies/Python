================================================================================
                ESTRUTURAS CONDICIONAIS E LOOPINGS EM PYTHON
                           N√çVEL INICIANTE
================================================================================



================================================================================
1. INTRODU√á√ÉO A ESTRUTURAS DE CONTROLE
================================================================================

1.1 O QUE S√ÉO ESTRUTURAS DE CONTROLE?
--------------------------------------------------------------------------------
Estruturas de controle determinam o fluxo de execu√ß√£o do programa. Elas 
permitem que o c√≥digo tome decis√µes (condicionais) e repita a√ß√µes (loops).

Sem estruturas de controle:
linha1()
linha2()
linha3()
# Executa sempre na mesma ordem, linha por linha

Com estruturas de controle:
if condicao:
    fazer_algo()  # Executa apenas se condi√ß√£o for verdadeira
else:
    fazer_outra_coisa()

1.2 POR QUE USAR ESTRUTURAS DE CONTROLE?
--------------------------------------------------------------------------------
Benef√≠cios das estruturas de controle:
- Permite que o programa tome decis√µes baseadas em condi√ß√µes
- Evita repeti√ß√£o de c√≥digo atrav√©s de loops
- Torna o c√≥digo mais flex√≠vel e din√¢mico
- Permite processamento de cole√ß√µes de dados
- Essencial para qualquer l√≥gica de programa√ß√£o

1.3 TIPOS DE ESTRUTURAS DE CONTROLE
--------------------------------------------------------------------------------
Condicionais: Tomam decis√µes
- if: executa c√≥digo se condi√ß√£o for verdadeira
- elif: testa condi√ß√µes alternativas
- else: executa se nenhuma condi√ß√£o anterior for verdadeira

Loops: Repetem a√ß√µes
- for: itera sobre sequ√™ncias (listas, strings, ranges)
- while: repete enquanto condi√ß√£o for verdadeira
- Controles: break, continue, pass


================================================================================
2. VALORES BOOLEANOS E OPERADORES
================================================================================

2.1 VALORES BOOLEANOS
--------------------------------------------------------------------------------
Em Python, existem apenas dois valores booleanos: True e False.

Valores booleanos diretos:
verdadeiro = True
falso = False

Convers√£o para booleano:
bool(1)        # True
bool(0)        # False
bool("texto")  # True
bool("")       # False
bool([1, 2])   # True
bool([])       # False

Valores considerados False (Falsy):
- False, None
- 0, 0.0, 0j
- "", [], (), {}, set()
- Objetos com __bool__() ou __len__() que retornam False ou 0

Valores considerados True (Truthy):
- Tudo que n√£o √© Falsy!

2.2 OPERADORES DE COMPARA√á√ÉO
--------------------------------------------------------------------------------
Comparam valores e retornam True ou False.

Operadores:
==    Igual a
!=    Diferente de
>     Maior que
<     Menor que
>=    Maior ou igual a
<=    Menor ou igual a

Exemplos:
5 == 5        # True
5 != 3        # True
10 > 5        # True
3 < 2         # False
7 >= 7        # True
4 <= 3        # False

Compara√ß√£o de strings:
"abc" == "abc"     # True
"abc" < "def"      # True (ordem alfab√©tica)
"Python" != "Java" # True

Comparando tipos:
5 == "5"      # False (int vs string)
5 == 5.0      # True (int vs float, valores iguais)

2.3 OPERADORES L√ìGICOS
--------------------------------------------------------------------------------
Combinam express√µes booleanas.

Operadores:
and    E l√≥gico (ambos devem ser True)
or     OU l√≥gico (pelo menos um deve ser True)
not    N√ÉO l√≥gico (inverte o valor)

Tabela verdade do AND:
True and True    # True
True and False   # False
False and True   # False
False and False  # False

Tabela verdade do OR:
True or True     # True
True or False    # True
False or True    # True
False or False   # False

Operador NOT:
not True         # False
not False        # True

Exemplos pr√°ticos:
idade = 25
tem_carteira = True

# AND: todas condi√ß√µes devem ser verdadeiras
if idade >= 18 and tem_carteira:
    print("Pode dirigir")

# OR: pelo menos uma condi√ß√£o deve ser verdadeira
dia = "s√°bado"
if dia == "s√°bado" or dia == "domingo":
    print("√â fim de semana!")

# NOT: inverte a condi√ß√£o
chovendo = False
if not chovendo:
    print("Pode sair sem guarda-chuva")

2.4 OPERADORES DE IDENTIDADE E PERTENCIMENTO
--------------------------------------------------------------------------------
Verificam identidade de objetos e pertencimento a cole√ß√µes.

Operadores de identidade:
is      Verifica se s√£o o mesmo objeto
is not  Verifica se n√£o s√£o o mesmo objeto

Exemplo:
a = [1, 2, 3]
b = [1, 2, 3]
c = a

a == b        # True (valores iguais)
a is b        # False (objetos diferentes)
a is c        # True (mesmo objeto)

Operadores de pertencimento:
in      Verifica se est√° contido
not in  Verifica se n√£o est√° contido

Exemplos:
"a" in "banana"           # True
3 in [1, 2, 3, 4]        # True
"x" not in "python"      # True
"chave" in {"chave": 1}  # True (verifica chaves em dicion√°rios)


================================================================================
3. ESTRUTURAS CONDICIONAIS (IF, ELIF, ELSE)
================================================================================

3.1 IF SIMPLES
--------------------------------------------------------------------------------
Executa c√≥digo apenas se a condi√ß√£o for verdadeira.

Sintaxe:
if condicao:
    # C√≥digo executado se condi√ß√£o for True
    instrucoes()

Exemplo b√°sico:
idade = 20
if idade >= 18:
    print("Voc√™ √© maior de idade")

M√∫ltiplas linhas no bloco:
temperatura = 35
if temperatura > 30:
    print("Est√° muito quente!")
    print("Beba bastante √°gua")
    print("Evite o sol")

IMPORTANTE: A indenta√ß√£o (espa√ßos) define o bloco!
if True:
    print("Dentro do if")  # 4 espa√ßos
print("Fora do if")        # Sem indenta√ß√£o

3.2 IF-ELSE
--------------------------------------------------------------------------------
Executa um bloco se condi√ß√£o for True, outro se for False.

Sintaxe:
if condicao:
    # Executado se True
    fazer_algo()
else:
    # Executado se False
    fazer_outra_coisa()

Exemplo:
nota = 7.5
if nota >= 7:
    print("Aprovado!")
else:
    print("Reprovado!")

Exemplo pr√°tico:
numero = int(input("Digite um n√∫mero: "))
if numero % 2 == 0:
    print(f"{numero} √© par")
else:
    print(f"{numero} √© √≠mpar")

3.3 IF-ELIF-ELSE
--------------------------------------------------------------------------------
Testa m√∫ltiplas condi√ß√µes em sequ√™ncia.

Sintaxe:
if condicao1:
    # Executado se condicao1 for True
    codigo1()
elif condicao2:
    # Executado se condicao1 for False e condicao2 for True
    codigo2()
elif condicao3:
    # Executado se anteriores forem False e condicao3 for True
    codigo3()
else:
    # Executado se todas as condi√ß√µes forem False
    codigo_padrao()

Exemplo de classifica√ß√£o:
nota = 8.5

if nota >= 9:
    print("Conceito A - Excelente!")
elif nota >= 7:
    print("Conceito B - Bom!")
elif nota >= 5:
    print("Conceito C - Regular")
else:
    print("Conceito D - Insuficiente")

Exemplo com faixas et√°rias:
idade = 15

if idade < 12:
    print("Crian√ßa")
elif idade < 18:
    print("Adolescente")
elif idade < 60:
    print("Adulto")
else:
    print("Idoso")

IMPORTANTE: Apenas o PRIMEIRO bloco verdadeiro √© executado!
numero = 10
if numero > 5:
    print("Maior que 5")     # Executado
elif numero > 3:
    print("Maior que 3")     # N√£o executado (mesmo sendo verdadeiro)
else:
    print("Menor ou igual a 5")

3.4 IFS ANINHADOS
--------------------------------------------------------------------------------
Voc√™ pode colocar if dentro de outro if.

Sintaxe:
if condicao1:
    if condicao2:
        # Executado se ambas forem True
        codigo()

Exemplo:
idade = 20
tem_habilitacao = True

if idade >= 18:
    if tem_habilitacao:
        print("Pode dirigir")
    else:
        print("Maior de idade, mas precisa de habilita√ß√£o")
else:
    print("Menor de idade, n√£o pode dirigir")

Melhor abordagem (usando 'and'):
if idade >= 18 and tem_habilitacao:
    print("Pode dirigir")

Exemplo com valida√ß√£o de login:
usuario = "admin"
senha = "123456"

if usuario == "admin":
    if senha == "123456":
        print("Login bem-sucedido!")
    else:
        print("Senha incorreta")
else:
    print("Usu√°rio n√£o encontrado")

3.5 OPERADOR TERN√ÅRIO (CONDICIONAL EM UMA LINHA)
--------------------------------------------------------------------------------
Forma compacta de if-else para atribui√ß√µes simples.

Sintaxe:
valor = resultado_se_true if condicao else resultado_se_false

Exemplos:
idade = 20
status = "maior" if idade >= 18 else "menor"
print(status)  # "maior"

numero = 7
tipo = "par" if numero % 2 == 0 else "√≠mpar"
print(tipo)  # "√≠mpar"

Compara√ß√£o:
# Forma tradicional:
if nota >= 7:
    resultado = "Aprovado"
else:
    resultado = "Reprovado"

# Forma tern√°ria:
resultado = "Aprovado" if nota >= 7 else "Reprovado"

Aninhamento (evite, pode ficar confuso):
nota = 8.5
conceito = "A" if nota >= 9 else "B" if nota >= 7 else "C"


================================================================================
4. ESTRUTURA DE REPETI√á√ÉO FOR
================================================================================

4.1 FOR B√ÅSICO
--------------------------------------------------------------------------------
Itera sobre sequ√™ncias (listas, tuplas, strings, ranges).

Sintaxe:
for variavel in sequencia:
    # C√≥digo executado para cada item
    processar(variavel)

Iterando sobre lista:
frutas = ["ma√ß√£", "banana", "laranja"]
for fruta in frutas:
    print(fruta)
# Sa√≠da:
# ma√ß√£
# banana
# laranja

Iterando sobre string:
for letra in "Python":
    print(letra)
# Sa√≠da: P y t h o n (uma letra por linha)

Iterando sobre tupla:
coordenadas = (10, 20, 30)
for valor in coordenadas:
    print(f"Valor: {valor}")

4.2 RANGE()
--------------------------------------------------------------------------------
Gera sequ√™ncias num√©ricas para loops.

Sintaxes de range:
range(parada)                # 0 at√© parada-1
range(inicio, parada)        # inicio at√© parada-1
range(inicio, parada, passo) # inicio at√© parada-1, com incremento

Exemplos b√°sicos:
# range(5) gera: 0, 1, 2, 3, 4
for i in range(5):
    print(i)

# range(2, 6) gera: 2, 3, 4, 5
for i in range(2, 6):
    print(i)

# range(0, 10, 2) gera: 0, 2, 4, 6, 8
for i in range(0, 10, 2):
    print(i)

# range decrescente
for i in range(10, 0, -1):
    print(i)  # 10, 9, 8, ..., 1

Exemplos pr√°ticos:
# Tabuada
numero = 5
for i in range(1, 11):
    print(f"{numero} x {i} = {numero * i}")

# Contagem regressiva
for i in range(10, 0, -1):
    print(i)
print("Feliz Ano Novo!")

4.3 ENUMERATE()
--------------------------------------------------------------------------------
Retorna √≠ndice e valor ao iterar.

Sintaxe:
for indice, valor in enumerate(sequencia):
    processar(indice, valor)

Exemplo b√°sico:
frutas = ["ma√ß√£", "banana", "laranja"]
for i, fruta in enumerate(frutas):
    print(f"{i}: {fruta}")
# Sa√≠da:
# 0: ma√ß√£
# 1: banana
# 2: laranja

Iniciando √≠ndice em 1:
for i, fruta in enumerate(frutas, start=1):
    print(f"{i}. {fruta}")
# Sa√≠da:
# 1. ma√ß√£
# 2. banana
# 3. laranja

Uso pr√°tico:
alunos = ["Ana", "Bruno", "Carlos"]
for posicao, nome in enumerate(alunos, 1):
    print(f"{posicao}¬∫ lugar: {nome}")

4.4 ITERANDO SOBRE DICION√ÅRIOS
--------------------------------------------------------------------------------
V√°rias formas de iterar sobre dicion√°rios.

Dicion√°rio de exemplo:
pessoa = {"nome": "Jo√£o", "idade": 30, "cidade": "S√£o Paulo"}

Iterando sobre chaves (padr√£o):
for chave in pessoa:
    print(chave)
# Sa√≠da: nome, idade, cidade

Iterando sobre chaves (expl√≠cito):
for chave in pessoa.keys():
    print(chave, pessoa[chave])

Iterando sobre valores:
for valor in pessoa.values():
    print(valor)
# Sa√≠da: Jo√£o, 30, S√£o Paulo

Iterando sobre pares chave-valor:
for chave, valor in pessoa.items():
    print(f"{chave}: {valor}")
# Sa√≠da:
# nome: Jo√£o
# idade: 30
# cidade: S√£o Paulo

Exemplo pr√°tico:
notas = {"Ana": 9.5, "Bruno": 7.0, "Carlos": 8.5}
for aluno, nota in notas.items():
    if nota >= 7:
        print(f"{aluno}: Aprovado ({nota})")
    else:
        print(f"{aluno}: Reprovado ({nota})")

4.5 ZIP() E ITERA√á√ÉO PARALELA
--------------------------------------------------------------------------------
Itera sobre m√∫ltiplas sequ√™ncias simultaneamente.

Sintaxe:
for item1, item2 in zip(lista1, lista2):
    processar(item1, item2)

Exemplo b√°sico:
nomes = ["Ana", "Bruno", "Carlos"]
idades = [25, 30, 22]

for nome, idade in zip(nomes, idades):
    print(f"{nome} tem {idade} anos")
# Sa√≠da:
# Ana tem 25 anos
# Bruno tem 30 anos
# Carlos tem 22 anos

Tr√™s ou mais listas:
nomes = ["Ana", "Bruno"]
idades = [25, 30]
cidades = ["SP", "RJ"]

for nome, idade, cidade in zip(nomes, idades, cidades):
    print(f"{nome}, {idade} anos, mora em {cidade}")

IMPORTANTE: zip para quando a menor lista acaba!
lista1 = [1, 2, 3]
lista2 = [10, 20]
for a, b in zip(lista1, lista2):
    print(a, b)
# Sa√≠da:
# 1 10
# 2 20
# (o 3 √© ignorado)

4.6 LIST COMPREHENSION
--------------------------------------------------------------------------------
Forma compacta de criar listas usando for.

Sintaxe b√°sica:
nova_lista = [expressao for item in sequencia]

Exemplo b√°sico:
# Forma tradicional:
quadrados = []
for x in range(5):
    quadrados.append(x ** 2)
# quadrados = [0, 1, 4, 9, 16]

# List comprehension:
quadrados = [x ** 2 for x in range(5)]

Com condi√ß√£o (filtro):
# Apenas n√∫meros pares
pares = [x for x in range(10) if x % 2 == 0]
# pares = [0, 2, 4, 6, 8]

# Apenas nomes com mais de 3 letras
nomes = ["Ana", "Bruno", "Carlos", "Di"]
nomes_longos = [nome for nome in nomes if len(nome) > 3]
# nomes_longos = ["Bruno", "Carlos"]

Transforma√ß√µes:
# Converter para mai√∫sculas
frutas = ["ma√ß√£", "banana", "uva"]
frutas_upper = [fruta.upper() for fruta in frutas]
# ["MA√á√É", "BANANA", "UVA"]

# Dobro de cada n√∫mero
numeros = [1, 2, 3, 4]
dobros = [n * 2 for n in numeros]
# [2, 4, 6, 8]

Com if-else:
numeros = [1, 2, 3, 4, 5]
resultado = ["par" if n % 2 == 0 else "√≠mpar" for n in numeros]
# ["√≠mpar", "par", "√≠mpar", "par", "√≠mpar"]

Aninhadas (listas 2D):
matriz = [[j for j in range(3)] for i in range(3)]
# [[0, 1, 2], [0, 1, 2], [0, 1, 2]]


================================================================================
5. ESTRUTURA DE REPETI√á√ÉO WHILE
================================================================================

5.1 WHILE B√ÅSICO
--------------------------------------------------------------------------------
Repete enquanto a condi√ß√£o for verdadeira.

Sintaxe:
while condicao:
    # C√≥digo executado enquanto condi√ß√£o for True
    instrucoes()

Exemplo b√°sico:
contador = 0
while contador < 5:
    print(contador)
    contador += 1
# Sa√≠da: 0, 1, 2, 3, 4

CUIDADO: Loop infinito!
# while True:
#     print("Isso nunca para!")  # N√£o execute isso!

Exemplo pr√°tico - valida√ß√£o:
senha = ""
while senha != "python":
    senha = input("Digite a senha: ")
print("Acesso liberado!")

5.2 WHILE COM CONTADOR
--------------------------------------------------------------------------------
Similar ao for, mas com controle manual do contador.

Exemplo:
i = 1
while i <= 10:
    print(i)
    i += 1

Contagem regressiva:
contador = 10
while contador > 0:
    print(contador)
    contador -= 1
print("Acabou!")

5.3 WHILE TRUE COM BREAK
--------------------------------------------------------------------------------
Loop infinito controlado por break.

Sintaxe comum:
while True:
    # C√≥digo
    if condicao_de_saida:
        break

Exemplo - menu:
while True:
    print("\n1. Op√ß√£o 1")
    print("2. Op√ß√£o 2")
    print("3. Sair")
    
    escolha = input("Escolha: ")
    
    if escolha == "1":
        print("Voc√™ escolheu 1")
    elif escolha == "2":
        print("Voc√™ escolheu 2")
    elif escolha == "3":
        print("Saindo...")
        break
    else:
        print("Op√ß√£o inv√°lida!")

Exemplo - jogo de adivinha√ß√£o:
import random

numero_secreto = random.randint(1, 100)
tentativas = 0

while True:
    palpite = int(input("Adivinhe o n√∫mero (1-100): "))
    tentativas += 1
    
    if palpite == numero_secreto:
        print(f"Acertou em {tentativas} tentativas!")
        break
    elif palpite < numero_secreto:
        print("Muito baixo!")
    else:
        print("Muito alto!")

5.4 WHILE COM ELSE
--------------------------------------------------------------------------------
O bloco else √© executado quando o loop termina normalmente (sem break).

Sintaxe:
while condicao:
    codigo()
else:
    # Executado quando condi√ß√£o se torna False
    codigo_finalizacao()

Exemplo:
contador = 0
while contador < 3:
    print(f"Contagem: {contador}")
    contador += 1
else:
    print("Loop conclu√≠do normalmente!")

# Sa√≠da:
# Contagem: 0
# Contagem: 1
# Contagem: 2
# Loop conclu√≠do normalmente!

Exemplo com break (else N√ÉO executa):
senha_correta = "python"
tentativas = 0
max_tentativas = 3

while tentativas < max_tentativas:
    senha = input("Senha: ")
    if senha == senha_correta:
        print("Acesso permitido!")
        break
    tentativas += 1
else:
    # S√≥ executa se n√£o houver break
    print("N√∫mero m√°ximo de tentativas excedido!")

5.5 FOR VS WHILE
--------------------------------------------------------------------------------
Quando usar cada um?

Use FOR quando:
- Souber o n√∫mero de itera√ß√µes
- Iterar sobre cole√ß√µes (listas, ranges)
- Processar cada elemento de uma sequ√™ncia

Exemplos:
for i in range(10):
    print(i)

for nome in ["Ana", "Bruno", "Carlos"]:
    print(nome)

Use WHILE quando:
- N√£o souber quantas itera√ß√µes ser√£o necess√°rias
- Continuar at√© uma condi√ß√£o espec√≠fica
- Criar loops infinitos controlados

Exemplos:
while not arquivo_processado:
    processar_linha()

while usuario_logado:
    executar_acao()

Compara√ß√£o - mesma tarefa:
# Com FOR:
for i in range(5):
    print(i)

# Com WHILE:
i = 0
while i < 5:
    print(i)
    i += 1


================================================================================
6. CONTROLE DE LOOPS (BREAK, CONTINUE, PASS)
================================================================================

6.1 BREAK
--------------------------------------------------------------------------------
Interrompe o loop imediatamente.

Sintaxe:
for item in sequencia:
    if condicao:
        break  # Sai do loop
    processar(item)

Exemplo em for:
for numero in range(10):
    if numero == 5:
        break
    print(numero)
# Sa√≠da: 0, 1, 2, 3, 4 (para no 5)

Exemplo em while:
contador = 0
while True:
    print(contador)
    contador += 1
    if contador >= 5:
        break
# Sa√≠da: 0, 1, 2, 3, 4

Uso pr√°tico - busca:
numeros = [10, 20, 30, 40, 50]
procurar = 30

for i, num in enumerate(numeros):
    if num == procurar:
        print(f"Encontrado na posi√ß√£o {i}")
        break
else:
    print("N√£o encontrado")

6.2 CONTINUE
--------------------------------------------------------------------------------
Pula para a pr√≥xima itera√ß√£o do loop.

Sintaxe:
for item in sequencia:
    if condicao:
        continue  # Pula para pr√≥xima itera√ß√£o
    processar(item)

Exemplo - pular n√∫meros pares:
for numero in range(10):
    if numero % 2 == 0:
        continue  # Pula pares
    print(numero)
# Sa√≠da: 1, 3, 5, 7, 9 (apenas √≠mpares)

Exemplo pr√°tico - processar apenas v√°lidos:
numeros = [1, -2, 3, -4, 5, -6]
soma = 0

for num in numeros:
    if num < 0:
        continue  # Pula negativos
    soma += num

print(f"Soma dos positivos: {soma}")  # 9

Filtrando entradas:
nomes = ["Ana", "", "Bruno", "", "Carlos"]
for nome in nomes:
    if not nome:  # Se vazio
        continue
    print(f"Ol√°, {nome}!")

6.3 PASS
--------------------------------------------------------------------------------
N√£o faz nada (placeholder).

Sintaxe:
if condicao:
    pass  # Fazer algo aqui depois

Quando usar:
- Estrutura que ainda ser√° implementada
- Evitar erro de sintaxe em blocos vazios
- Placeholder em desenvolvimento

Exemplo em if:
idade = 17
if idade >= 18:
    pass  # TODO: implementar verifica√ß√£o de maioridade
else:
    print("Menor de idade")

Exemplo em loop:
for i in range(10):
    if i % 2 == 0:
        pass  # TODO: processar pares
    else:
        print(f"√çmpar: {i}")

Classe vazia (comum em desenvolvimento):
class MinhaClasse:
    pass  # Implementar depois

Fun√ß√£o vazia:
def minha_funcao():
    pass  # Implementar depois

6.4 COMBINANDO BREAK E CONTINUE
--------------------------------------------------------------------------------
Usando break e continue juntos em loops complexos.

Exemplo - processar at√© encontrar condi√ß√£o:
numeros = [1, 2, 3, -1, 4, 5]

for num in numeros:
    if num < 0:
        print("N√∫mero negativo encontrado, parando")
        break
    if num % 2 == 0:
        continue  # Pula pares
    print(f"√çmpar positivo: {num}")

# Sa√≠da:
# √çmpar positivo: 1
# √çmpar positivo: 3
# N√∫mero negativo encontrado, parando

Valida√ß√£o com continue e processamento:
dados = ["123", "abc", "456", "def", "789"]
numeros_validos = []

for item in dados:
    if not item.isdigit():
        continue  # Pula n√£o-num√©ricos
    
    numero = int(item)
    if numero > 500:
        break  # Para se encontrar n√∫mero muito alto
    
    numeros_validos.append(numero)

print(numeros_validos)  # [123, 456]

6.5 ELSE EM LOOPS
--------------------------------------------------------------------------------
Bloco else executa quando loop termina normalmente (sem break).

Sintaxe:
for item in sequencia:
    if condicao:
        break
else:
    # Executado se n√£o houver break
    codigo()

Exemplo - verificar se n√∫mero √© primo:
numero = 17
for i in range(2, numero):
    if numero % i == 0:
        print(f"{numero} n√£o √© primo")
        break
else:
    print(f"{numero} √© primo")

Exemplo - busca com resultado:
nomes = ["Ana", "Bruno", "Carlos"]
procurar = "Diana"

for nome in nomes:
    if nome == procurar:
        print(f"{procurar} encontrado!")
        break
else:
    print(f"{procurar} n√£o encontrado na lista")


================================================================================
7. LOOPS ANINHADOS
================================================================================

7.1 FOR ANINHADO
--------------------------------------------------------------------------------
Loop dentro de outro loop.

Sintaxe:
for item1 in sequencia1:
    for item2 in sequencia2:
        # Executado para cada combina√ß√£o
        processar(item1, item2)

Exemplo - tabela de multiplica√ß√£o:
for i in range(1, 4):
    for j in range(1, 4):
        print(f"{i} x {j} = {i * j}")
    print()  # Linha em branco

# Sa√≠da:
# 1 x 1 = 1
# 1 x 2 = 2
# 1 x 3 = 3
#
# 2 x 1 = 2
# 2 x 2 = 4
# ...

Matriz (lista 2D):
matriz = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

for linha in matriz:
    for elemento in linha:
        print(elemento, end=" ")
    print()  # Nova linha

# Sa√≠da:
# 1 2 3
# 4 5 6
# 7 8 9

Exemplo - combina√ß√µes:
cores = ["vermelho", "azul"]
tamanhos = ["P", "M", "G"]

for cor in cores:
    for tamanho in tamanhos:
        print(f"{cor} - {tamanho}")

# Sa√≠da:
# vermelho - P
# vermelho - M
# vermelho - G
# azul - P
# azul - M
# azul - G

7.2 WHILE ANINHADO
--------------------------------------------------------------------------------
While dentro de outro while.

Exemplo - menu com submenus:
while True:
    print("\nMenu Principal")
    print("1. Submenu")
    print("2. Sair")
    
    opcao = input("Escolha: ")
    
    if opcao == "1":
        while True:
            print("\nSubmenu")
            print("1. A√ß√£o A")
            print("2. Voltar")
            
            sub_opcao = input("Escolha: ")
            
            if sub_opcao == "1":
                print("Executando a√ß√£o A")
            elif sub_opcao == "2":
                break  # Sai do submenu
    
    elif opcao == "2":
        break  # Sai do menu principal

7.3 BREAK EM LOOPS ANINHADOS
--------------------------------------------------------------------------------
Break s√≥ sai do loop mais interno.

Exemplo:
for i in range(3):
    print(f"Loop externo: {i}")
    for j in range(3):
        if j == 1:
            break  # S√≥ sai do loop interno
        print(f"  Loop interno: {j}")
    print("Fim da itera√ß√£o externa")

# Sa√≠da:
# Loop externo: 0
#   Loop interno: 0
# Fim da itera√ß√£o externa
# Loop externo: 1
#   Loop interno: 0
# Fim da itera√ß√£o externa
# ...

Para sair de ambos os loops, use flag:
encontrado = False
for i in range(3):
    for j in range(3):
        if alguma_condicao:
            encontrado = True
            break
    if encontrado:
        break

7.4 PADR√ïES COMUNS COM LOOPS ANINHADOS
--------------------------------------------------------------------------------
Exemplos pr√°ticos de uso.

Busca em matriz:
matriz = [[1, 2], [3, 4], [5, 6]]
procurar = 4

for i, linha in enumerate(matriz):
    for j, valor in enumerate(linha):
        if valor == procurar:
            print(f"Encontrado na posi√ß√£o [{i}][{j}]")

Criar padr√µes:
# Tri√¢ngulo
for i in range(1, 6):
    for j in range(i):
        print("*", end="")
    print()

# Sa√≠da:
# *
# **
# ***
# ****
# *****

Tabuleiro:
tamanho = 8
for i in range(tamanho):
    for j in range(tamanho):
        if (i + j) % 2 == 0:
            print("‚¨ú", end="")
        else:
            print("‚¨õ", end="")
    print()


================================================================================
8. PADR√ïES E BOAS PR√ÅTICAS
================================================================================

8.1 VALIDA√á√ÉO DE ENTRADA
--------------------------------------------------------------------------------
Padr√£o robusto para entrada do usu√°rio.

Entrada num√©rica:
def obter_numero():
    while True:
        try:
            entrada = input("Digite um n√∫mero: ")
            numero = float(entrada)
            return numero
        except ValueError:
            print("Entrada inv√°lida! Digite um n√∫mero.")

Entrada com valida√ß√£o:
def obter_idade():
    while True:
        idade = obter_numero()
        if 0 <= idade <= 150:
            return int(idade)
        print("Idade deve estar entre 0 e 150!")

Entrada de op√ß√µes:
def obter_opcao(opcoes_validas):
    while True:
        opcao = input(f"Escolha {opcoes_validas}: ")
        if opcao in opcoes_validas:
            return opcao
        print("Op√ß√£o inv√°lida!")

# Uso:
opcao = obter_opcao(['s', 'n'])

8.2 PROCESSAMENTO DE LISTAS
--------------------------------------------------------------------------------
Padr√µes comuns para trabalhar com listas.

Soma de elementos:
numeros = [1, 2, 3, 4, 5]
soma = 0
for num in numeros:
    soma += num
# Ou simplesmente: soma = sum(numeros)

Encontrar m√°ximo/m√≠nimo:
numeros = [45, 12, 78, 23, 56]
maximo = numeros[0]
for num in numeros:
    if num > maximo:
        maximo = num
# Ou: maximo = max(numeros)

Filtrar elementos:
numeros = [1, 2, 3, 4, 5, 6]
pares = []
for num in numeros:
    if num % 2 == 0:
        pares.append(num)
# Ou: pares = [n for n in numeros if n % 2 == 0]

Contar ocorr√™ncias:
frutas = ["ma√ß√£", "banana", "ma√ß√£", "laranja", "ma√ß√£"]
contador = 0
for fruta in frutas:
    if fruta == "ma√ß√£":
        contador += 1
# Ou: contador = frutas.count("ma√ß√£")

8.3 ACUMULADORES E CONTADORES
--------------------------------------------------------------------------------
Padr√µes para acumular valores durante loops.

Contador simples:
contador = 0
for item in lista:
    if condicao(item):
        contador += 1

Acumulador de soma:
total = 0
for numero in numeros:
    total += numero

Acumulador de produto:
produto = 1
for numero in numeros:
    produto *= numero

Constru√ß√£o de string:
resultado = ""
for palavra in palavras:
    resultado += palavra + " "

# Melhor:
resultado = " ".join(palavras)

M√∫ltiplos acumuladores:
positivos = 0
negativos = 0
zeros = 0

for num in numeros:
    if num > 0:
        positivos += 1
    elif num < 0:
        negativos += 1
    else:
        zeros += 1

8.4 EARLY RETURN
--------------------------------------------------------------------------------
Retornar cedo de fun√ß√µes para evitar aninhamento.

Sem early return (aninhado):
def processar_usuario(usuario):
    if usuario is not None:
        if usuario.ativo:
            if usuario.idade >= 18:
                return f"Processando {usuario.nome}"
            else:
                return "Menor de idade"
        else:
            return "Usu√°rio inativo"
    else:
        return "Usu√°rio n√£o encontrado"

Com early return (mais limpo):
def processar_usuario(usuario):
    if usuario is None:
        return "Usu√°rio n√£o encontrado"
    
    if not usuario.ativo:
        return "Usu√°rio inativo"
    
    if usuario.idade < 18:
        return "Menor de idade"
    
    return f"Processando {usuario.nome}"

8.5 ENUMERATE PARA MODIFICA√á√ÉO
--------------------------------------------------------------------------------
Use enumerate quando precisar do √≠ndice.

Sem enumerate (n√£o recomendado):
frutas = ["ma√ß√£", "banana", "laranja"]
for i in range(len(frutas)):
    frutas[i] = frutas[i].upper()

Com enumerate (melhor):
for i, fruta in enumerate(frutas):
    frutas[i] = fruta.upper()

# Melhor ainda (list comprehension):
frutas = [fruta.upper() for fruta in frutas]

8.6 EVITANDO LOOPS DESNECESS√ÅRIOS
--------------------------------------------------------------------------------
Use m√©todos built-in quando poss√≠vel.

Verificar se existe:
# Lento:
encontrado = False
for item in lista:
    if item == procurar:
        encontrado = True
        break

# R√°pido:
encontrado = procurar in lista

Contar:
# Manual:
contador = 0
for item in lista:
    if item == valor:
        contador += 1

# Built-in:
contador = lista.count(valor)

Somar:
# Manual:
total = 0
for num in numeros:
    total += num

# Built-in:
total = sum(numeros)

8.7 GUARD CLAUSES
--------------------------------------------------------------------------------
Valida√ß√µes no in√≠cio da fun√ß√£o.

Sem guard clauses:
def processar_pedido(pedido):
    if pedido.valido:
        if pedido.pago:
            if pedido.em_estoque:
                # Processar
                return processar(pedido)

Com guard clauses:
def processar_pedido(pedido):
    if not pedido.valido:
        return "Pedido inv√°lido"
    
    if not pedido.pago:
        return "Pagamento pendente"
    
    if not pedido.em_estoque:
        return "Produto fora de estoque"
    
    return processar(pedido)


================================================================================
9. EXEMPLOS PR√ÅTICOS COMPLETOS
================================================================================

9.1 CALCULADORA SIMPLES
--------------------------------------------------------------------------------
while True:
    print("\n=== CALCULADORA ===")
    print("1. Somar")
    print("2. Subtrair")
    print("3. Multiplicar")
    print("4. Dividir")
    print("5. Sair")
    
    opcao = input("\nEscolha uma op√ß√£o: ")
    
    if opcao == "5":
        print("Saindo...")
        break
    
    if opcao not in ["1", "2", "3", "4"]:
        print("Op√ß√£o inv√°lida!")
        continue
    
    try:
        num1 = float(input("Primeiro n√∫mero: "))
        num2 = float(input("Segundo n√∫mero: "))
        
        if opcao == "1":
            resultado = num1 + num2
            print(f"Resultado: {resultado}")
        elif opcao == "2":
            resultado = num1 - num2
            print(f"Resultado: {resultado}")
        elif opcao == "3":
            resultado = num1 * num2
            print(f"Resultado: {resultado}")
        elif opcao == "4":
            if num2 == 0:
                print("Erro: divis√£o por zero!")
            else:
                resultado = num1 / num2
                print(f"Resultado: {resultado}")
    
    except ValueError:
        print("Erro: entrada inv√°lida!")

9.2 JOGO DE ADIVINHA√á√ÉO
--------------------------------------------------------------------------------
import random

def jogo_adivinhacao():
    print("=== JOGO DE ADIVINHA√á√ÉO ===")
    print("Estou pensando em um n√∫mero entre 1 e 100")
    
    numero_secreto = random.randint(1, 100)
    tentativas = 0
    max_tentativas = 7
    
    while tentativas < max_tentativas:
        tentativas_restantes = max_tentativas - tentativas
        print(f"\nTentativas restantes: {tentativas_restantes}")
        
        try:
            palpite = int(input("Seu palpite: "))
            
            if palpite < 1 or palpite > 100:
                print("Por favor, digite um n√∫mero entre 1 e 100!")
                continue
            
            tentativas += 1
            
            if palpite == numero_secreto:
                print(f"\nüéâ Parab√©ns! Voc√™ acertou em {tentativas} tentativas!")
                break
            elif palpite < numero_secreto:
                print("üìà Muito baixo!")
            else:
                print("üìâ Muito alto!")
        
        except ValueError:
            print("Por favor, digite um n√∫mero v√°lido!")
    
    else:
        print(f"\nüòû Suas tentativas acabaram!")
        print(f"O n√∫mero era {numero_secreto}")

jogo_adivinhacao()

9.3 LISTA DE TAREFAS
--------------------------------------------------------------------------------
def lista_tarefas():
    tarefas = []
    
    while True:
        print("\n=== LISTA DE TAREFAS ===")
        print("1. Adicionar tarefa")
        print("2. Listar tarefas")
        print("3. Marcar como conclu√≠da")
        print("4. Remover tarefa")
        print("5. Sair")
        
        opcao = input("\nEscolha: ")
        
        if opcao == "1":
            tarefa = input("Nova tarefa: ")
            if tarefa:
                tarefas.append({"texto": tarefa, "concluida": False})
                print("‚úÖ Tarefa adicionada!")
            else:
                print("Tarefa n√£o pode ser vazia!")
        
        elif opcao == "2":
            if not tarefas:
                print("Nenhuma tarefa cadastrada!")
            else:
                print("\nSuas tarefas:")
                for i, tarefa in enumerate(tarefas, 1):
                    status = "‚úì" if tarefa["concluida"] else " "
                    print(f"{i}. [{status}] {tarefa['texto']}")
        
        elif opcao == "3":
            if not tarefas:
                print("Nenhuma tarefa para marcar!")
            else:
                try:
                    num = int(input("N√∫mero da tarefa: "))
                    if 1 <= num <= len(tarefas):
                        tarefas[num - 1]["concluida"] = True
                        print("‚úÖ Tarefa marcada como conclu√≠da!")
                    else:
                        print("N√∫mero inv√°lido!")
                except ValueError:
                    print("Digite um n√∫mero v√°lido!")
        
        elif opcao == "4":
            if not tarefas:
                print("Nenhuma tarefa para remover!")
            else:
                try:
                    num = int(input("N√∫mero da tarefa: "))
                    if 1 <= num <= len(tarefas):
                        removida = tarefas.pop(num - 1)
                        print(f"üóëÔ∏è Removida: {removida['texto']}")
                    else:
                        print("N√∫mero inv√°lido!")
                except ValueError:
                    print("Digite um n√∫mero v√°lido!")
        
        elif opcao == "5":
            print("At√© logo!")
            break
        
        else:
            print("Op√ß√£o inv√°lida!")

9.4 AN√ÅLISE DE DADOS
--------------------------------------------------------------------------------
def analisar_notas():
    print("=== AN√ÅLISE DE NOTAS ===")
    print("Digite as notas (ou 'fim' para terminar)")
    
    notas = []
    
    while True:
        entrada = input("Nota: ")
        
        if entrada.lower() == "fim":
            break
        
        try:
            nota = float(entrada)
            if 0 <= nota <= 10:
                notas.append(nota)
            else:
                print("Nota deve estar entre 0 e 10!")
        except ValueError:
            print("Digite um n√∫mero v√°lido ou 'fim'!")
    
    if not notas:
        print("Nenhuma nota foi inserida!")
        return
    
    # An√°lise
    media = sum(notas) / len(notas)
    maior = max(notas)
    menor = min(notas)
    
    aprovados = 0
    reprovados = 0
    for nota in notas:
        if nota >= 7:
            aprovados += 1
        else:
            reprovados += 1
    
    # Resultados
    print("\n=== RESULTADOS ===")
    print(f"Total de notas: {len(notas)}")
    print(f"M√©dia: {media:.2f}")
    print(f"Maior nota: {maior:.2f}")
    print(f"Menor nota: {menor:.2f}")
    print(f"Aprovados (‚â•7): {aprovados}")
    print(f"Reprovados (<7): {reprovados}")
    
    # Distribui√ß√£o
    print("\nDistribui√ß√£o:")
    for i in range(0, 11, 2):
        faixa_inicial = i
        faixa_final = i + 2
        quantidade = sum(1 for n in notas if faixa_inicial <= n < faixa_final)
        if i == 10:
            quantidade = sum(1 for n in notas if n == 10)
        barra = "‚ñà" * quantidade
        print(f"{faixa_inicial}-{faixa_final}: {barra} ({quantidade})")

9.5 VALIDADOR DE CPF
--------------------------------------------------------------------------------
def validar_cpf(cpf):
    # Remove pontos e tra√ßos
    cpf = cpf.replace(".", "").replace("-", "")
    
    # Verifica se tem 11 d√≠gitos
    if len(cpf) != 11 or not cpf.isdigit():
        return False
    
    # Verifica se todos os d√≠gitos s√£o iguais
    if cpf == cpf[0] * 11:
        return False
    
    # Calcula primeiro d√≠gito verificador
    soma = 0
    for i in range(9):
        soma += int(cpf[i]) * (10 - i)
    
    digito1 = 11 - (soma % 11)
    if digito1 > 9:
        digito1 = 0
    
    if int(cpf[9]) != digito1:
        return False
    
    # Calcula segundo d√≠gito verificador
    soma = 0
    for i in range(10):
        soma += int(cpf[i]) * (11 - i)
    
    digito2 = 11 - (soma % 11)
    if digito2 > 9:
        digito2 = 0
    
    if int(cpf[10]) != digito2:
        return False
    
    return True

# Teste
cpf = input("Digite o CPF: ")
if validar_cpf(cpf):
    print("‚úÖ CPF v√°lido!")
else:
    print("‚ùå CPF inv√°lido!")


================================================================================
RESUMO R√ÅPIDO
================================================================================

ESTRUTURAS CONDICIONAIS:
if condicao:
    codigo()
elif outra_condicao:
    codigo()
else:
    codigo()

# Tern√°rio
valor = resultado_if_true if condicao else resultado_if_false

LOOP FOR:
for item in sequencia:
    processar(item)

# Range
for i in range(inicio, fim, passo):
    codigo()

# Enumerate
for i, valor in enumerate(lista):
    codigo()

# Comprehension
lista = [expressao for item in sequencia if condicao]

LOOP WHILE:
while condicao:
    codigo()

# Infinito controlado
while True:
    if condicao_saida:
        break

CONTROLE DE LOOPS:
break     # Sai do loop
continue  # Pula para pr√≥xima itera√ß√£o
pass      # N√£o faz nada (placeholder)

OPERADORES:
==, !=, >, <, >=, <=     # Compara√ß√£o
and, or, not             # L√≥gicos
in, not in              # Pertencimento
is, is not              # Identidade

CONCEITOS-CHAVE:
- Indenta√ß√£o define blocos de c√≥digo
- Condi√ß√µes retornam True ou False
- For para itera√ß√µes conhecidas
- While para itera√ß√µes condicionais
- Break interrompe loops
- Continue pula itera√ß√£o
- Else funciona em loops (executa se n√£o houver break)

BOAS PR√ÅTICAS:
‚úÖ Use for para iterar sobre cole√ß√µes
‚úÖ Use while quando n√£o souber o n√∫mero de itera√ß√µes
‚úÖ Prefira list comprehension para listas simples
‚úÖ Use enumerate quando precisar de √≠ndices
‚úÖ Valide entrada do usu√°rio com loops
‚úÖ Use break para sair de loops infinitos
‚úÖ Evite loops aninhados profundos
‚úÖ Use guard clauses para valida√ß√µes
‚úÖ Prefira m√©todos built-in (sum, max, min, in)

‚ùå Evite modificar lista durante itera√ß√£o
‚ùå Evite loops desnecess√°rios
‚ùå N√£o use range(len(lista)) quando n√£o precisar do √≠ndice
‚ùå Evite aninhamento excessivo de ifs
‚ùå N√£o deixe loops infinitos sem break

DICAS:
- Teste condi√ß√µes booleanas diretamente (if lista: em vez de if len(lista) > 0:)
- Use any() e all() para verificar condi√ß√µes em sequ√™ncias
- Combine zip() com for para iterar m√∫ltiplas listas
- Use dict comprehension: {k: v for k, v in items}
- Use set comprehension: {x for x in lista}
- Lembre-se: em Python, indenta√ß√£o √© crucial!


================================================================================
DOCUMENTA√á√ÉO OFICIAL DO PYTHON - ESTRUTURAS DE CONTROLE
================================================================================

================================================================================
PRINCIPAL - ESTRUTURAS DE CONTROLE
================================================================================
https://docs.python.org/3/tutorial/controlflow.html
Tutorial oficial sobre estruturas de controle de fluxo

================================================================================
DOCUMENTA√á√ÉO DETALHADA
================================================================================
https://docs.python.org/3/reference/compound_stmts.html#the-if-statement
Refer√™ncia completa da declara√ß√£o if

https://docs.python.org/3/reference/compound_stmts.html#the-for-statement
Refer√™ncia completa da declara√ß√£o for

https://docs.python.org/3/reference/compound_stmts.html#the-while-statement
Refer√™ncia completa da declara√ß√£o while

https://docs.python.org/3/reference/simple_stmts.html#break
Declara√ß√£o break

https://docs.python.org/3/reference/simple_stmts.html#continue
Declara√ß√£o continue

https://docs.python.org/3/reference/simple_stmts.html#pass
Declara√ß√£o pass

================================================================================
FUN√á√ïES E ITERADORES
================================================================================
https://docs.python.org/3/library/functions.html#range
Fun√ß√£o range()

https://docs.python.org/3/library/functions.html#enumerate
Fun√ß√£o enumerate()

https://docs.python.org/3/library/functions.html#zip
Fun√ß√£o zip()

https://docs.python.org/3/library/stdtypes.html#iterator-types
Tipos iteradores

================================================================================
EXPRESS√ïES E OPERADORES
================================================================================
https://docs.python.org/3/reference/expressions.html#comparisons
Operadores de compara√ß√£o

https://docs.python.org/3/reference/expressions.html#boolean-operations
Opera√ß√µes booleanas

https://docs.python.org/3/reference/expressions.html#membership-test-operations
Operadores de pertencimento (in, not in)

https://docs.python.org/3/reference/expressions.html#is-not
Operadores de identidade (is, is not)

================================================================================
LIST COMPREHENSIONS E EXPRESS√ïES GERADORAS
================================================================================
https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions
List comprehensions

https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries
Displays para listas, sets e dicion√°rios

================================================================================
				AGRIPPA
================================================================================